# 浏览器内存模型 - 由JS引擎管理

在浏览器环境下就是 V8引擎

栈内存：存放原始类型值，生命周期短，不由GC回收而是由引擎自动弹栈

堆内存：存放引用数据类型，由GC进行回收

# 垃圾回收机制

JS 是自动垃圾回收语言，不用显式地 free()

JS 的 GC 主要依赖可达性，当一个对象**从根对象不可达时就会判定为垃圾**

根对象包括：

- 全局对象 window / globalThis
- 当前执行栈
- 闭包引用的变量
- DOM树

现代 V8 引擎主要用两种 GC 算法

1. 标记清除：从根对象开始扫描，对所有可达对象打上标签，如果没有标记的就进行清除
2. 分代垃圾回收：V8会把堆分为两部分
    1. 新生代：对象存活时间短、GC频繁、速度快，例如局部变量
    2. 老生代：存活时间久的，如大型对象、闭包、全局缓存
    
    新生代用复制算法（将内存分为**From空间和To空间**，每次垃圾回收时把From里仍存活的对象复制到To中，再交换两个空间角色，那么没有复制的自然久变成了垃圾）
    
    老生代用标记压缩算法（标记、清除、如果有必要再压缩，如果分配一个大对象时由于内存没有连续的空间会导致GC频繁触发，所以就必须**压缩**整理碎片）
    

# 前端常见的内存泄漏来源

## 1. 未清理定时器/回调

在设置一个 setInterval 之后没有手动 clearInterval

## 2. 事件监听器未移除

```jsx
window.addEventListener('scroll', () => {})
```

在组件卸载之后仍然存在

React中使用 hooks 时尤其容易发生，所以别忘记将卸载函数返回

```jsx
useEffect(() => {
	window.addEventListener('sroll', handler)
	return () => window.removeEventListener('scroll', handler);
},[]);
```

那么返回函数在组件卸载时会自动触发进行清理

## 3. 闭包引用了不该引用的标量

例如 箭头函数返回了

```jsx
function bad() {
	const bigData = new Array(10000);
	return () => bigData;
}
```

返回的箭头函数中需要 bigData 才能运行，所以这个标记就会一直保留

## 4. 全局变量泄漏

```jsx
function fn() {
	leak = "oops"
}
```

**在局部作用域中没有写 var /  let / const 所以就会隐式触发挂到 global 上**

( var 挂到的是**当前作用域的顶层对象**，只要不是在全局作用域中就不会挂到全局对象上）

## 5. DOM 引用被缓存导致无法释放

删除了DOM但是JS里面还是有引用

```jsx
const el = document.getElementById("box");
document.body.removeChild(el);
// el 仍然引用 → 不可回收
```

## 6. 缓存 / Map / WeakMap 使用不当

### Map会强引用（内存中不会自动释放）

```jsx
const m = new Map();
m.set(key, value);
// key 永远不会释放
```

### 只有 WeakMap 才会自动 GC

```jsx
const wm = new WeakMap();
wm.set(obj, value); // obj不可达时自动回收
```

# 进行排查

通过 开发者工具中的性能 查看 Memory profiling 和堆快照，找一直没有清除的甚至一直增长的内存空间

# 设置过期策略

## 1. TTL：时间过期

看 Date.now() 是否大于 cached.expire 设置的过期时间，如果超过了就 delete

一般包装在 localStorage 中，**因为 localStorage 没有自动过期机制**

```jsx
const cache = new Map();

function setCache(key, value, ttl = 5000) {
  cache.set(key, {
    value,
    expire: Date.now() + ttl,
  });
}

function getCache(key) {
  const cached = cache.get(key);
  if (!cached) return null;

  if (Date.now() > cached.expire) {
    cache.delete(key);
    return null;
  }
  return cached.value;
}

```

## 2. LRU 缓存：数量有限、最近使用的

每次 set 和 get 的时候就更新优先级（JS 的 Map 是自动有序的）

```jsx
class LRUCache {
  constructor(limit = 100) {
    this.limit = limit;
    this.map = new Map();
  }

  get(key) {
    if (!this.map.has(key)) return null;
    const value = this.map.get(key);
    // 每次访问移动到结尾（最新使用）
    this.map.delete(key);
    this.map.set(key, value);
    return value;
  }

  set(key, value) {
    if (this.map.has(key)) this.map.delete(key);
    else if (this.map.size >= this.limit) {
      // 删除最久未使用的值（Map 的第一个值）
      const oldestKey = this.map.keys().next().value;
      this.map.delete(oldestKey);
    }
    this.map.set(key, value);
  }
}

```

## 3. LFU：根据访问次数进行淘汰

## 4. 内存占用的清除

管理一个队列

```jsx
let currentSize = 0;
const MAX_SIZE = 5 * 1024 * 1024; // 5MB
const cache = [];

function addToCache(obj) {
  const size = JSON.stringify(obj).length;

  while (currentSize + size > MAX_SIZE) {
    const removed = cache.shift(); // 移除一个最旧的
    currentSize -= JSON.stringify(removed).length;
  }

  cache.push(obj);
  currentSize += size;
}
```

## 5. 利用 WeakMap 不是强引用，让GC自动清除
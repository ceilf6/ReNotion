前端：通过 Web 技术实现用户界面和交互功能

虽然像 jQuery 库已经帮助我们简单地处理了一些 DOM 节点的操作、事件绑定

随着代码复杂度的提高，代码维护、DOM操作的延时等等都需要优化，社区的解决方案就是**组件化**，将一个页面拆解为具有结构、表现、行为完整的一个个单元，也就是组件。每个交互模块被隔离在一个独立的组件之内

框架统一了开发规范，内置了数据绑定、路由、状态管理等功能，以及高效更新 DOM 节点的算法，解决了原生开发的混乱和低效

## 流行框架

2024年 State of Frontend 报告，前端生态框架中

React、Vue、Svelte（编译型框架的代表）、Angular 依然是流行框架

# React

## 发展历程

在第二个建立生态的阶段，维护者很聪明地将React区分为 React和 React-Dom 两个库，这样 React既能运行在网页上，也能通过 React Native 变成手机上的 APP ，实现了组件的跨端共享。同年，**Redux** 的出现完美解决了复杂应用的状态管理难题

第三个-架构更新阶段，重写了整个渲染引擎，支持异步渲染和任务优先级的调度，为后续的并发模式奠基，这就是著名的 **Fiber 架构**

V16.8版本推出了 **Hooks** ，彻底改变了写组件的方式，从类组件变成了 函数式编程

V18 支持自动的 批处理，减少不必要的渲染，流式的服务端渲染，提升了首屏的速度，像 startTransition 保持了 UI 的响应性，现在 React 正在向 服务端的组件发展，以及像 React Forget 的编译器可以自动优化渲染性能

[React.dev](http://React.dev) 文档的上线完全转向了函数组件和 Hooks 的教学

## 声明式

React组件必须以大写组件开头

HTML组件必须是小写字母开头

export default 声明了文件中主要的组件，每一个 React 组件都是JS的 **函数** ，通过JSX来表示标签，在JSX中通过 { } 写JS，函数返回的只能是一个组件

React 组件间通过 props 来相互通信，每一个父组件都可以提供 props 给子组件，从而将一些信息传递给它

props 是不可以变的，当需要新的时候子组件就需要请求父组件传递一个新的对象

需要交互的时候一般需要状态变量 State ，useState 是 React 的一个内置 Hook ，返回 状态变量 以及它的setter函数，在改变的时候自动通知 UI 去渲染，组件根据当前的一个 props 和 state 用 JSX 去描述，React将其转换为真正的 DOM 元素，在第一次 以及 props或state 改变的时候组件都会触发渲染

React 奉行的就是 **数据驱动视图**，代码只需要管理数据，React 去高效更新 UI ，这被称为 **声明式**。开发者只需要关注做什么、而不是怎么做，框架自动更新视图

## React内部对DOM的管理

每一个UI都可以用树结构进行展示

React 从组件中创建 UI树，这颗树最终会用于渲染 DOM

通过嵌套结构描述 UI 的节点、属性、层级关系

称之为 虚拟DOM

它是在 JS 内存里面维护的一颗 与 真实DOM 映射的UI树

当 React 需要更新的时候不是直接去调用浏览器内部的 DOM 的API ，而是先在内存里面种一颗虚拟树，用 diff 算法去快速找出两颗树之间的差异点，找出最小的变更集，减少重绘和回流（重排、布局）

本质是将 昂贵的DOM操作 通过 JS对象的预处理 进行避免开销

## Diff算法的三大原则

### 1. 只对同一层中的节点进行比较

不会跨层级地去追踪，如果画跨层级了直接销毁旧的、创建新的

这样 **避免递归** 了，从递归两颗树*递归比较差异的O(n**3)变成了 O(n)

### 2. 只比较相同类型的元素或标签

比如像 div 标签是不会与 span 进行对比的，当根节点不同类型的元素时，React 也是直接销毁旧的、创建新的

当卸载一颗树的时候其DOM节点（包括下面的）会被销毁

### 3. 用 key 标识一个列表项

当递归DOM节点的一个子元素的时候，React会重新遍历两个子元素的列表，当产生变化的时候，会生成一个新的**写**操作，在子元素列表在最后插入一个元素的时候，更新的开销会比较小，会优先匹配第一个元素的树，然后是第二个，再插入第三个元素。

如果只是简单的将新增元素插入到表头，开销就会变大，React意识不到它应该保留第一个和第二个元素，而是重建每一个子元素。所以 React 引入了 key 的属性，就是通过 key 来匹配旧的树上的子元素以及最新树上的子元素

虚拟DOM DIff 是内存的一个操作，对比JS的对象 比操作真实的DOM快100倍

首先，DOM的操作是昂贵的，简单的文本更新都触发浏览器的样式重新计算、重排、重绘、图层的重组，重排是用时最长的，一次重拍的耗时比 JS 的对象操作慢 100 到 1000倍。其次，原生的 DOM 操作没有批量更新，会导致多次重排，所以最优的思路是先知道最后的结果怎么样再统一只触发一次重拍，以往开发者是先隐藏这个容器，在完成批量操作之后再再次展现这个容器，

React 调用 setState 去更新状态，而状态的更新是异步的，React会将多次的 setState 调用汇总为一次更新，避免频繁的变动

## 状态管理

React是单向数据流，如果多个组件需要共享和使用相同的一个state的时候，React基础方案就是状态提升（最近公共祖先），通过 props 将信息从父组件传递下来，但是如果要跨层级，状态提升会需要很多层，逐层传递、中间组件被迫传递一堆不需要的props，那么顶层的状态变化会引发整颗树的一个重渲染

多个、不集中的地方需要共享状态

状态更新逻辑复杂

需要强大的事件旅行调试（记忆化），支持撤销、重做的操作管理能力，比如像腾讯文档

（React内部的 Context API 也支持跨层级共享状态，但是仅适合数据流相对线形、更新不频繁的应用）

### Redux

为解决此，社区诞生了状态管理库 Redux ，其使用叫做 Action 的事件去管理和更新应用状态的一个模式和工具库，以集中式 Store 的方式去对整个应用中的状态进行集中化的处理，确保了状态可以以可预测的方式去更新，Redux 去帮助开发者管理全局的状态

所有 Redux 的应用中心都是 **Store**，是保存应用程序的一个全局 state 的容器，是一个 JS对象 ，有特殊的功能和能力，组件不能直接修改 Store 里面的状态，想修改就必须创建一个 Action ，Action就是一个普通的JS对象，必须有一个 type 字段去描述想干嘛，还能带一些额外的数据，组件通过调用 Dispatch 将这个 Action 派发给 Store ，相当于向中央仓库提交了一个修改单

仓库收到 Action 之后不会自己去改变状态，会去找 Reducer ，Reducer 是一个纯函数，其接收两个参数，一个是当前Store 的状态，第二个是收到的修改申请单 Action ，Reducer的工作就是根据 Action 的 type 以及 它携带的数据，结合当前的 state 去计算并返回一个全新的 state 对象

Store 拿到 Reducer 返回的新对象后就会替换旧的状态（注意，必须是新的对象，而不是修改原状态），状态更新后 Store 会通知所有订阅了状态变化（订阅的是变化事件而不是状态本身！）的组件，~~那么这些组件会用 getState 去读取、更新最新的数据、触发渲染。~~不是组件主动去 getState 拿数据，而是在如 useSelector、connect 他们内部获取最新状态并触发相关渲染

# Vue

Vue提供了一种另外的响应式体验，它会更隐式的去自动追踪依赖，取代了手动状态的分发。让开发者能够更专注于数据的逻辑，而不是更新的机制

2013年尤雨溪在Google工作的时候受到Angular的启发，开发出了更轻量级的框架Seed，后更名为Vue，当时只有数据绑定和组件化的雏形，这个阶段可以定位为渐进式库，强调低侵入性，可以直接用 script 标签引入

2016，2.0，引入了虚拟DOM、提升了渲染性能，支持服务端渲染和跨端方案

Vuex 解决了组件间状态共享的难题，有了标准化的脚手架，开箱即用的SSR（Server-Side Rendering服务端渲染）方案，

- 在服务端把页面提前渲染成 HTML 再返回给浏览器的技术，能优化首屏体验、更利于SEO
    
    客户端渲染：浏览器先下载JS、执行JS、执行渲染
    

社区中也涌现出了 Element UI 的组件库

3.0 完全重构，解决了两大包袱

1. 提升了**响应式性能**，Vue2响应式依赖 Object.defineProperty ，每个属性都必须递归地劫持，无法监听新增 / 删除组件，而Vue3 用了 Proxy ，解决了前面的问题
2. 原先 Vue2 用的是 Options API，功能逻辑被打散，mixins会冲突、来源不明等，而 Vue3 的组合式 Composition API ，提升了TS推导，和 React Hooks 类似的 按逻辑组织代码 ，解决了 选项式API带来的“逻辑碎片化”和“复用困难”

在性能优化上，

还有 **Tree-Shaking** 的支持，Tree-Shaking = 摇掉没有用到的代码（Dead Code Elimination），现代构建工具 Vite/Rollup 会进行静态分析：找出哪些没有被引用，构建时将没有用到的部分从 bundle 中删除，让打包体积更小、性能更快，但是Vue2将所有API都挂在Vue对象上（Vue.component(…) , Vue.use(…) ）构建工具无法判断用了哪些 API ，但是 Vue3 用了模块化API

```tsx
import { ref, reactive, defineComponent } from 'vue'
```

、源码 TypeScript 化、

Fragment ：组件可以返回多个根元素，而无需一个包裹 div 

等新特性

现在 Vue 团队仍在颠覆他们自己，现在有两个方向

1. Vaper Mode 实验性的编译策略，**弃用了虚拟DOM，直接输出更高效的 JS代码** ，减少内存和运行时的开销
2. 工具链的强化，用 Rust 重写了一个构建工具，速度提升了 5倍

## 核心概念

Vue提供了一套声明式的、组件化的一个编程模型

Vue 使用基于 HTML 的模版语法，使开发者能够声明式地将组建的一个实例数据绑定到呈现的 DOM 上，所有的 Vue 模版都是语法层面上的一个合法 HTML

最基本的数据绑定形式是文本插值，使用 **双**大括号 语法（胡子），双大括号的标签就会被替换为相应的组件当中的一个 对应名称的 属性值，实现视图和数据的联动

## 指令是带 v- 前缀的特殊属性attribute

attribute 属性（HTML标签上的键值对）

常见的有

- v-bind （或者简写的冒号 : ）用于动态的绑定 HTML 的一个 **属性** ，例如 :href = “url” ，就能让 href 这个属性随着 url 的变量进行变化
- v-on （简写 @ ）可以用于绑定一个 DOM 的 **事件**监听器，像 @click = “handleClick” ，那么发生点击事件时就会触发 handleClick 这个方法
- v-model 用于 **双向** 数据绑定，主要用于 **表单** 中输入元素，本质是 **:value + @input** 的 **语法糖** ，v-modal = ”message” 相当于绑定数据到 DOM元素 的一个 value 属性，将数据模型的初始值显示在数据图中，监听 DOM 元素的一个 input 事件，当用户在输入框中输入内容的时候，就会触发 input 事件，Vue 就会获取新的值，并更新数据模型，处理表单更方便

上面的message就是 **数据模型** ，MVVM 中的 Model 即

Vue3中：ref / reactive 定义的变量

```tsx
const message = ref('');
```

Vue2中：data() 的返回值

```tsx
data() {
  return {
    message: ''
  }
}
```

| **层** | **Vue 对应** |
| --- | --- |
| Model（数据模型） | data() / ref() / reactive() 中的变量 |
| View（视图层） | HTML 模板 <template> |
| ViewModel（数据绑定层） | Vue 内部的响应式系统 |

ViewModel 是 Vue 的核心区域，里面通过 DOM 的 事件监听器listener 监听我们的 DOM事件，另一边通过 指令操作DOM、Proxy+effect依赖收集监听数据Model的变化（Vue2用的是Object.defineProperty+依赖收集-观察者watcher），连接 View 和 Model数据，实现数据驱动视图、视图交互更新数据的双向绑定流程

而像 **React 并不是观察者模式，并不会自动观察数据的变化**。React的数据是 Immutable不可变数据，其状态数据与视图的联动靠的是

 **“开发者告诉 React 我变了“ 显式 setState 通知机制 + Fiber 调度机制**

Fiber纤维比线程轻量得多，每个组件对应一个 Fiber Node，它们组成 **Fiber Tree ，是可操作的虚拟 DOM** 节点，上面存储了

> Fiber 是 React 16 引入的全新渲染架构，通过把渲染任务拆分为可中断的小任务，并引入优先级调度，使 React 能避免长时间阻塞主线程，从而保持 UI 的流畅。
> 

> Fiber 包含两个阶段：Render（可中断） 和 Commit（不可中断）。
> 

> 它是 React 实现异步渲染、并发模式、startTransition、自动批处理等特性的核心基础。
> 

## 组合式API

核心思想：直接在函数作用域内定义响应式的状态变量，并将从多个函数中得到的状态变量组合起来，处理复杂问题

Vue3 推荐用 API 风格

```tsx
import { createApp, ref } from 'vue'
```

createApp 函数可以创建一个 Vue 的应用实例

setup函数是组合式API的核心区域，执行在组件的实例化之前，setup 返回了模版需要的内容，例如状态变量 或者 需要被绑定的点击事件方法都可以 return 出去

## 虚拟DOM

和React一样，当响应式数据发生变化触发全新渲染时，Vue也会生成新的虚拟DOM树，将新的和旧的进行比较，计算最小需要的变化，核心思想是一致的，具体实现细节上两者各有优化

**Vue 和 React 都用虚拟 DOM，但 Vue 的虚拟 DOM + diff 更“模板驱动、静态可分析、自动优化”，而 React 的虚拟 DOM 更“运行时函数式、纯 JS 计算”。**

Vue 在编译阶段做了大量优化，而 React 基本依赖运行时代码本身。

1. Vue有编译时，可以做静态优化：只patch真正变化的地方
2. Vue 是模版驱动，结构固定，模版确定性更强，所以渲染树的结构可预测，而React的render是纯JS，其UI是动态不可预测的
3. **Vue 的 Patch 过程是“指令化”的 / React 是“diff 型”的**
4. **Vue 3 有 Block Tree（块树），React 没有：只对动态部分简历block，更新时只patch block 的 dynamicChildren**

patch 补丁，是指在虚拟DOM构建成功后，将旧的和新的比较后同步到新的上的过程

响应式数据在 **setup** 中需要通过 **.value** 进行访问，

setup 会 return 响应式数据模型 以及 事件方法

而**在模版中不需要 .value** 进行访问，模版中会自动解包
将数据模块以及方法 return 出去这样模版就能使用到了

## Vue响应式原理 - 自动更新视图

Vue靠的是劫持对象属性的读写，来实现跟踪，我们没有办法直接去追踪局部变量的读写

**响应式的本质就是劫持数据**

- 获取数据的时候设置依赖
- 更新数据的时候触发通知

在JS中有两种挟持 属性property 访问的方式

1. Vue2使用的是getter/setter，完全是基于支持旧浏览器的限制。
    
    defineReactive （是Vue内部封装的函数，当访问某个变量的时候Vue就会记录下哪个watcher使用了它）接收的对象 obj 和属性 key，先存下属性值value然后用 **Object.defineProperty 重写 get 和 set**，当访问属性的时候会执行 track，这一步是依赖的收集，记录了谁在用这个属性（即订阅者），修改属性的时候更新 value 然后执行 trigger ，触发更新，通知所有订阅者
    
    组件渲染函数的执行会 Touch 数据的一个 getter，此时 watcher 会把自己作为依赖，通过 Collect as Dependency关联到数据当中，相当于告诉数据我要用你了，你变了之后记得通知我，当数据变了之后会触发 trigger 通知 Watcher ， 后者收到通知后就会触发 re-render ，让组件重新渲染，更新虚拟DOM
    
    总结下来就是
    
    defineReactive会将一个数据模块响应化，那么调用getter使用到其的地方就会被收录到这个数据模块的watcher列表中，一旦这个数据模块setter变更之后，trigger（派发更新 - dep.notify）就会通知watcher
    
2. Vue3改用了 **Proxy** 创建一个响应式对象，Proxy能够直接的监听对象，不用遍历属性去响应化，还能监听新增、删除的操作

# React与Vue差异 - 选择框架

## 共同点

1. 组件化 的开发思想
2. 虚拟DOM优化性能
3. 响应式数据，数据驱动视图
4. 丰富的周边工具：路由、状态管理

## 差异

1. React走 **函数式编程**，认为 UI是数据的函数
    
    Vue 靠的是 **响应式 + 模版**
    
2. 更新触发：React得 **显式** 手动地调用 setState 和 useState，告诉UI数据变了
    
    Vue是 **自动依赖** 追踪
    
3. 语法：react 用 JSX 和 HTML 混写
    
    Vue用的是模版语法
    
4. React 更加 **自由** ；Vue全家桶开发更快速

## 小程序 - 双线程

小程序不是单一的技术，而是一种应用形态和技术方案，

其目标是提供一种更接近原生的APP体验，开发成本更低

小程序主要运行在超级APP内部，由APP提供运行环境，可以理解为运行在特殊浏览器内部

分为逻辑层和视图层

逻辑层跑在独立的线程里，与浏览器的环境隔离，意味着JS的一些能力BOM等等不能动，不能主动操作DOM只能通过通知视图层变更

两边的生命周期是联动的，生命周期钩子同时触发

双线程是为了安全性，性能优化